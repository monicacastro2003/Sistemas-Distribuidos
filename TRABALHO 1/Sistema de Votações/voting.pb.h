// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: voting.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_voting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_voting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_voting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_voting_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_voting_2eproto;
namespace voting {
class AdminNotice;
struct AdminNoticeDefaultTypeInternal;
extern AdminNoticeDefaultTypeInternal _AdminNotice_default_instance_;
class Candidate;
struct CandidateDefaultTypeInternal;
extern CandidateDefaultTypeInternal _Candidate_default_instance_;
class CandidateResult;
struct CandidateResultDefaultTypeInternal;
extern CandidateResultDefaultTypeInternal _CandidateResult_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class Results;
struct ResultsDefaultTypeInternal;
extern ResultsDefaultTypeInternal _Results_default_instance_;
class VoteReply;
struct VoteReplyDefaultTypeInternal;
extern VoteReplyDefaultTypeInternal _VoteReply_default_instance_;
class VoteRequest;
struct VoteRequestDefaultTypeInternal;
extern VoteRequestDefaultTypeInternal _VoteRequest_default_instance_;
}  // namespace voting
PROTOBUF_NAMESPACE_OPEN
template<> ::voting::AdminNotice* Arena::CreateMaybeMessage<::voting::AdminNotice>(Arena*);
template<> ::voting::Candidate* Arena::CreateMaybeMessage<::voting::Candidate>(Arena*);
template<> ::voting::CandidateResult* Arena::CreateMaybeMessage<::voting::CandidateResult>(Arena*);
template<> ::voting::LoginReply* Arena::CreateMaybeMessage<::voting::LoginReply>(Arena*);
template<> ::voting::LoginRequest* Arena::CreateMaybeMessage<::voting::LoginRequest>(Arena*);
template<> ::voting::Results* Arena::CreateMaybeMessage<::voting::Results>(Arena*);
template<> ::voting::VoteReply* Arena::CreateMaybeMessage<::voting::VoteReply>(Arena*);
template<> ::voting::VoteRequest* Arena::CreateMaybeMessage<::voting::VoteRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace voting {

// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoterIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string voterId = 1;
  void clear_voterid();
  const std::string& voterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voterid();
  PROTOBUF_NODISCARD std::string* release_voterid();
  void set_allocated_voterid(std::string* voterid);
  private:
  const std::string& _internal_voterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voterid(const std::string& value);
  std::string* _internal_mutable_voterid();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:voting.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voterid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  explicit PROTOBUF_CONSTEXPR LoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReply& from) {
    LoginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 3,
    kMessageFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .voting.Candidate candidates = 3;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;
  public:
  void clear_candidates();
  ::voting::Candidate* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::Candidate >*
      mutable_candidates();
  private:
  const ::voting::Candidate& _internal_candidates(int index) const;
  ::voting::Candidate* _internal_add_candidates();
  public:
  const ::voting::Candidate& candidates(int index) const;
  ::voting::Candidate* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::Candidate >&
      candidates() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:voting.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::Candidate > candidates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class Candidate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Candidate) */ {
 public:
  inline Candidate() : Candidate(nullptr) {}
  ~Candidate() override;
  explicit PROTOBUF_CONSTEXPR Candidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Candidate(const Candidate& from);
  Candidate(Candidate&& from) noexcept
    : Candidate() {
    *this = ::std::move(from);
  }

  inline Candidate& operator=(const Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Candidate& operator=(Candidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Candidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Candidate* internal_default_instance() {
    return reinterpret_cast<const Candidate*>(
               &_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Candidate& a, Candidate& b) {
    a.Swap(&b);
  }
  inline void Swap(Candidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Candidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Candidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Candidate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Candidate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Candidate& from) {
    Candidate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Candidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Candidate";
  }
  protected:
  explicit Candidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPartyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string party = 3;
  void clear_party();
  const std::string& party() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_party(ArgT0&& arg0, ArgT... args);
  std::string* mutable_party();
  PROTOBUF_NODISCARD std::string* release_party();
  void set_allocated_party(std::string* party);
  private:
  const std::string& _internal_party() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_party(const std::string& value);
  std::string* _internal_mutable_party();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:voting.Candidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class VoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.VoteRequest) */ {
 public:
  inline VoteRequest() : VoteRequest(nullptr) {}
  ~VoteRequest() override;
  explicit PROTOBUF_CONSTEXPR VoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteRequest(const VoteRequest& from);
  VoteRequest(VoteRequest&& from) noexcept
    : VoteRequest() {
    *this = ::std::move(from);
  }

  inline VoteRequest& operator=(const VoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteRequest& operator=(VoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteRequest* internal_default_instance() {
    return reinterpret_cast<const VoteRequest*>(
               &_VoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VoteRequest& a, VoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoteRequest& from) {
    VoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.VoteRequest";
  }
  protected:
  explicit VoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoterIdFieldNumber = 1,
    kCandidateIdFieldNumber = 2,
  };
  // string voterId = 1;
  void clear_voterid();
  const std::string& voterid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voterid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voterid();
  PROTOBUF_NODISCARD std::string* release_voterid();
  void set_allocated_voterid(std::string* voterid);
  private:
  const std::string& _internal_voterid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voterid(const std::string& value);
  std::string* _internal_mutable_voterid();
  public:

  // int32 candidateId = 2;
  void clear_candidateid();
  int32_t candidateid() const;
  void set_candidateid(int32_t value);
  private:
  int32_t _internal_candidateid() const;
  void _internal_set_candidateid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:voting.VoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voterid_;
    int32_t candidateid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class VoteReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.VoteReply) */ {
 public:
  inline VoteReply() : VoteReply(nullptr) {}
  ~VoteReply() override;
  explicit PROTOBUF_CONSTEXPR VoteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteReply(const VoteReply& from);
  VoteReply(VoteReply&& from) noexcept
    : VoteReply() {
    *this = ::std::move(from);
  }

  inline VoteReply& operator=(const VoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteReply& operator=(VoteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteReply* internal_default_instance() {
    return reinterpret_cast<const VoteReply*>(
               &_VoteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VoteReply& a, VoteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoteReply& from) {
    VoteReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.VoteReply";
  }
  protected:
  explicit VoteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kAcceptedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool accepted = 1;
  void clear_accepted();
  bool accepted() const;
  void set_accepted(bool value);
  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:voting.VoteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool accepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class AdminNotice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.AdminNotice) */ {
 public:
  inline AdminNotice() : AdminNotice(nullptr) {}
  ~AdminNotice() override;
  explicit PROTOBUF_CONSTEXPR AdminNotice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminNotice(const AdminNotice& from);
  AdminNotice(AdminNotice&& from) noexcept
    : AdminNotice() {
    *this = ::std::move(from);
  }

  inline AdminNotice& operator=(const AdminNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminNotice& operator=(AdminNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminNotice* internal_default_instance() {
    return reinterpret_cast<const AdminNotice*>(
               &_AdminNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AdminNotice& a, AdminNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminNotice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminNotice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminNotice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminNotice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminNotice& from) {
    AdminNotice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminNotice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.AdminNotice";
  }
  protected:
  explicit AdminNotice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kBodyFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string body = 2;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:voting.AdminNotice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class Results final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Results) */ {
 public:
  inline Results() : Results(nullptr) {}
  ~Results() override;
  explicit PROTOBUF_CONSTEXPR Results(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Results(const Results& from);
  Results(Results&& from) noexcept
    : Results() {
    *this = ::std::move(from);
  }

  inline Results& operator=(const Results& from) {
    CopyFrom(from);
    return *this;
  }
  inline Results& operator=(Results&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Results& default_instance() {
    return *internal_default_instance();
  }
  static inline const Results* internal_default_instance() {
    return reinterpret_cast<const Results*>(
               &_Results_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Results& a, Results& b) {
    a.Swap(&b);
  }
  inline void Swap(Results* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Results* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Results* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Results>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Results& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Results& from) {
    Results::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Results* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Results";
  }
  protected:
  explicit Results(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kTotalVotesFieldNumber = 2,
  };
  // repeated .voting.CandidateResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::voting::CandidateResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::CandidateResult >*
      mutable_results();
  private:
  const ::voting::CandidateResult& _internal_results(int index) const;
  ::voting::CandidateResult* _internal_add_results();
  public:
  const ::voting::CandidateResult& results(int index) const;
  ::voting::CandidateResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::CandidateResult >&
      results() const;

  // int32 totalVotes = 2;
  void clear_totalvotes();
  int32_t totalvotes() const;
  void set_totalvotes(int32_t value);
  private:
  int32_t _internal_totalvotes() const;
  void _internal_set_totalvotes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:voting.Results)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::CandidateResult > results_;
    int32_t totalvotes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// -------------------------------------------------------------------

class CandidateResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.CandidateResult) */ {
 public:
  inline CandidateResult() : CandidateResult(nullptr) {}
  ~CandidateResult() override;
  explicit PROTOBUF_CONSTEXPR CandidateResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CandidateResult(const CandidateResult& from);
  CandidateResult(CandidateResult&& from) noexcept
    : CandidateResult() {
    *this = ::std::move(from);
  }

  inline CandidateResult& operator=(const CandidateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CandidateResult& operator=(CandidateResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CandidateResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CandidateResult* internal_default_instance() {
    return reinterpret_cast<const CandidateResult*>(
               &_CandidateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CandidateResult& a, CandidateResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CandidateResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CandidateResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CandidateResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CandidateResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CandidateResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CandidateResult& from) {
    CandidateResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CandidateResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.CandidateResult";
  }
  protected:
  explicit CandidateResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 1,
    kPercentFieldNumber = 3,
    kVotesFieldNumber = 2,
  };
  // .voting.Candidate candidate = 1;
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::voting::Candidate& candidate() const;
  PROTOBUF_NODISCARD ::voting::Candidate* release_candidate();
  ::voting::Candidate* mutable_candidate();
  void set_allocated_candidate(::voting::Candidate* candidate);
  private:
  const ::voting::Candidate& _internal_candidate() const;
  ::voting::Candidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::voting::Candidate* candidate);
  ::voting::Candidate* unsafe_arena_release_candidate();

  // double percent = 3;
  void clear_percent();
  double percent() const;
  void set_percent(double value);
  private:
  double _internal_percent() const;
  void _internal_set_percent(double value);
  public:

  // int32 votes = 2;
  void clear_votes();
  int32_t votes() const;
  void set_votes(int32_t value);
  private:
  int32_t _internal_votes() const;
  void _internal_set_votes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:voting.CandidateResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::voting::Candidate* candidate_;
    double percent_;
    int32_t votes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_voting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string voterId = 1;
inline void LoginRequest::clear_voterid() {
  _impl_.voterid_.ClearToEmpty();
}
inline const std::string& LoginRequest::voterid() const {
  // @@protoc_insertion_point(field_get:voting.LoginRequest.voterId)
  return _internal_voterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_voterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.LoginRequest.voterId)
}
inline std::string* LoginRequest::mutable_voterid() {
  std::string* _s = _internal_mutable_voterid();
  // @@protoc_insertion_point(field_mutable:voting.LoginRequest.voterId)
  return _s;
}
inline const std::string& LoginRequest::_internal_voterid() const {
  return _impl_.voterid_.Get();
}
inline void LoginRequest::_internal_set_voterid(const std::string& value) {
  
  _impl_.voterid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_voterid() {
  
  return _impl_.voterid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_voterid() {
  // @@protoc_insertion_point(field_release:voting.LoginRequest.voterId)
  return _impl_.voterid_.Release();
}
inline void LoginRequest::set_allocated_voterid(std::string* voterid) {
  if (voterid != nullptr) {
    
  } else {
    
  }
  _impl_.voterid_.SetAllocated(voterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voterid_.IsDefault()) {
    _impl_.voterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.LoginRequest.voterId)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:voting.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:voting.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:voting.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginReply

// bool ok = 1;
inline void LoginReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool LoginReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool LoginReply::ok() const {
  // @@protoc_insertion_point(field_get:voting.LoginReply.ok)
  return _internal_ok();
}
inline void LoginReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void LoginReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:voting.LoginReply.ok)
}

// string message = 2;
inline void LoginReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LoginReply::message() const {
  // @@protoc_insertion_point(field_get:voting.LoginReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.LoginReply.message)
}
inline std::string* LoginReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:voting.LoginReply.message)
  return _s;
}
inline const std::string& LoginReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LoginReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReply::release_message() {
  // @@protoc_insertion_point(field_release:voting.LoginReply.message)
  return _impl_.message_.Release();
}
inline void LoginReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.LoginReply.message)
}

// repeated .voting.Candidate candidates = 3;
inline int LoginReply::_internal_candidates_size() const {
  return _impl_.candidates_.size();
}
inline int LoginReply::candidates_size() const {
  return _internal_candidates_size();
}
inline void LoginReply::clear_candidates() {
  _impl_.candidates_.Clear();
}
inline ::voting::Candidate* LoginReply::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:voting.LoginReply.candidates)
  return _impl_.candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::Candidate >*
LoginReply::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:voting.LoginReply.candidates)
  return &_impl_.candidates_;
}
inline const ::voting::Candidate& LoginReply::_internal_candidates(int index) const {
  return _impl_.candidates_.Get(index);
}
inline const ::voting::Candidate& LoginReply::candidates(int index) const {
  // @@protoc_insertion_point(field_get:voting.LoginReply.candidates)
  return _internal_candidates(index);
}
inline ::voting::Candidate* LoginReply::_internal_add_candidates() {
  return _impl_.candidates_.Add();
}
inline ::voting::Candidate* LoginReply::add_candidates() {
  ::voting::Candidate* _add = _internal_add_candidates();
  // @@protoc_insertion_point(field_add:voting.LoginReply.candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::Candidate >&
LoginReply::candidates() const {
  // @@protoc_insertion_point(field_list:voting.LoginReply.candidates)
  return _impl_.candidates_;
}

// -------------------------------------------------------------------

// Candidate

// int32 id = 1;
inline void Candidate::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Candidate::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Candidate::id() const {
  // @@protoc_insertion_point(field_get:voting.Candidate.id)
  return _internal_id();
}
inline void Candidate::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Candidate::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:voting.Candidate.id)
}

// string name = 2;
inline void Candidate::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Candidate::name() const {
  // @@protoc_insertion_point(field_get:voting.Candidate.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Candidate.name)
}
inline std::string* Candidate::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:voting.Candidate.name)
  return _s;
}
inline const std::string& Candidate::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Candidate::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Candidate::release_name() {
  // @@protoc_insertion_point(field_release:voting.Candidate.name)
  return _impl_.name_.Release();
}
inline void Candidate::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.Candidate.name)
}

// string party = 3;
inline void Candidate::clear_party() {
  _impl_.party_.ClearToEmpty();
}
inline const std::string& Candidate::party() const {
  // @@protoc_insertion_point(field_get:voting.Candidate.party)
  return _internal_party();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_party(ArgT0&& arg0, ArgT... args) {
 
 _impl_.party_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Candidate.party)
}
inline std::string* Candidate::mutable_party() {
  std::string* _s = _internal_mutable_party();
  // @@protoc_insertion_point(field_mutable:voting.Candidate.party)
  return _s;
}
inline const std::string& Candidate::_internal_party() const {
  return _impl_.party_.Get();
}
inline void Candidate::_internal_set_party(const std::string& value) {
  
  _impl_.party_.Set(value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_party() {
  
  return _impl_.party_.Mutable(GetArenaForAllocation());
}
inline std::string* Candidate::release_party() {
  // @@protoc_insertion_point(field_release:voting.Candidate.party)
  return _impl_.party_.Release();
}
inline void Candidate::set_allocated_party(std::string* party) {
  if (party != nullptr) {
    
  } else {
    
  }
  _impl_.party_.SetAllocated(party, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.party_.IsDefault()) {
    _impl_.party_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.Candidate.party)
}

// -------------------------------------------------------------------

// VoteRequest

// string voterId = 1;
inline void VoteRequest::clear_voterid() {
  _impl_.voterid_.ClearToEmpty();
}
inline const std::string& VoteRequest::voterid() const {
  // @@protoc_insertion_point(field_get:voting.VoteRequest.voterId)
  return _internal_voterid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteRequest::set_voterid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voterid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.VoteRequest.voterId)
}
inline std::string* VoteRequest::mutable_voterid() {
  std::string* _s = _internal_mutable_voterid();
  // @@protoc_insertion_point(field_mutable:voting.VoteRequest.voterId)
  return _s;
}
inline const std::string& VoteRequest::_internal_voterid() const {
  return _impl_.voterid_.Get();
}
inline void VoteRequest::_internal_set_voterid(const std::string& value) {
  
  _impl_.voterid_.Set(value, GetArenaForAllocation());
}
inline std::string* VoteRequest::_internal_mutable_voterid() {
  
  return _impl_.voterid_.Mutable(GetArenaForAllocation());
}
inline std::string* VoteRequest::release_voterid() {
  // @@protoc_insertion_point(field_release:voting.VoteRequest.voterId)
  return _impl_.voterid_.Release();
}
inline void VoteRequest::set_allocated_voterid(std::string* voterid) {
  if (voterid != nullptr) {
    
  } else {
    
  }
  _impl_.voterid_.SetAllocated(voterid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voterid_.IsDefault()) {
    _impl_.voterid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.VoteRequest.voterId)
}

// int32 candidateId = 2;
inline void VoteRequest::clear_candidateid() {
  _impl_.candidateid_ = 0;
}
inline int32_t VoteRequest::_internal_candidateid() const {
  return _impl_.candidateid_;
}
inline int32_t VoteRequest::candidateid() const {
  // @@protoc_insertion_point(field_get:voting.VoteRequest.candidateId)
  return _internal_candidateid();
}
inline void VoteRequest::_internal_set_candidateid(int32_t value) {
  
  _impl_.candidateid_ = value;
}
inline void VoteRequest::set_candidateid(int32_t value) {
  _internal_set_candidateid(value);
  // @@protoc_insertion_point(field_set:voting.VoteRequest.candidateId)
}

// -------------------------------------------------------------------

// VoteReply

// bool accepted = 1;
inline void VoteReply::clear_accepted() {
  _impl_.accepted_ = false;
}
inline bool VoteReply::_internal_accepted() const {
  return _impl_.accepted_;
}
inline bool VoteReply::accepted() const {
  // @@protoc_insertion_point(field_get:voting.VoteReply.accepted)
  return _internal_accepted();
}
inline void VoteReply::_internal_set_accepted(bool value) {
  
  _impl_.accepted_ = value;
}
inline void VoteReply::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:voting.VoteReply.accepted)
}

// string message = 2;
inline void VoteReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& VoteReply::message() const {
  // @@protoc_insertion_point(field_get:voting.VoteReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.VoteReply.message)
}
inline std::string* VoteReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:voting.VoteReply.message)
  return _s;
}
inline const std::string& VoteReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void VoteReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* VoteReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* VoteReply::release_message() {
  // @@protoc_insertion_point(field_release:voting.VoteReply.message)
  return _impl_.message_.Release();
}
inline void VoteReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.VoteReply.message)
}

// -------------------------------------------------------------------

// AdminNotice

// string title = 1;
inline void AdminNotice::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& AdminNotice::title() const {
  // @@protoc_insertion_point(field_get:voting.AdminNotice.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminNotice::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.AdminNotice.title)
}
inline std::string* AdminNotice::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:voting.AdminNotice.title)
  return _s;
}
inline const std::string& AdminNotice::_internal_title() const {
  return _impl_.title_.Get();
}
inline void AdminNotice::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminNotice::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminNotice::release_title() {
  // @@protoc_insertion_point(field_release:voting.AdminNotice.title)
  return _impl_.title_.Release();
}
inline void AdminNotice::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.AdminNotice.title)
}

// string body = 2;
inline void AdminNotice::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& AdminNotice::body() const {
  // @@protoc_insertion_point(field_get:voting.AdminNotice.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminNotice::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.AdminNotice.body)
}
inline std::string* AdminNotice::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:voting.AdminNotice.body)
  return _s;
}
inline const std::string& AdminNotice::_internal_body() const {
  return _impl_.body_.Get();
}
inline void AdminNotice::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* AdminNotice::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* AdminNotice::release_body() {
  // @@protoc_insertion_point(field_release:voting.AdminNotice.body)
  return _impl_.body_.Release();
}
inline void AdminNotice::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:voting.AdminNotice.body)
}

// int64 timestamp = 3;
inline void AdminNotice::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t AdminNotice::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t AdminNotice::timestamp() const {
  // @@protoc_insertion_point(field_get:voting.AdminNotice.timestamp)
  return _internal_timestamp();
}
inline void AdminNotice::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void AdminNotice::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:voting.AdminNotice.timestamp)
}

// -------------------------------------------------------------------

// Results

// repeated .voting.CandidateResult results = 1;
inline int Results::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int Results::results_size() const {
  return _internal_results_size();
}
inline void Results::clear_results() {
  _impl_.results_.Clear();
}
inline ::voting::CandidateResult* Results::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:voting.Results.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::CandidateResult >*
Results::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:voting.Results.results)
  return &_impl_.results_;
}
inline const ::voting::CandidateResult& Results::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::voting::CandidateResult& Results::results(int index) const {
  // @@protoc_insertion_point(field_get:voting.Results.results)
  return _internal_results(index);
}
inline ::voting::CandidateResult* Results::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::voting::CandidateResult* Results::add_results() {
  ::voting::CandidateResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:voting.Results.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::CandidateResult >&
Results::results() const {
  // @@protoc_insertion_point(field_list:voting.Results.results)
  return _impl_.results_;
}

// int32 totalVotes = 2;
inline void Results::clear_totalvotes() {
  _impl_.totalvotes_ = 0;
}
inline int32_t Results::_internal_totalvotes() const {
  return _impl_.totalvotes_;
}
inline int32_t Results::totalvotes() const {
  // @@protoc_insertion_point(field_get:voting.Results.totalVotes)
  return _internal_totalvotes();
}
inline void Results::_internal_set_totalvotes(int32_t value) {
  
  _impl_.totalvotes_ = value;
}
inline void Results::set_totalvotes(int32_t value) {
  _internal_set_totalvotes(value);
  // @@protoc_insertion_point(field_set:voting.Results.totalVotes)
}

// -------------------------------------------------------------------

// CandidateResult

// .voting.Candidate candidate = 1;
inline bool CandidateResult::_internal_has_candidate() const {
  return this != internal_default_instance() && _impl_.candidate_ != nullptr;
}
inline bool CandidateResult::has_candidate() const {
  return _internal_has_candidate();
}
inline void CandidateResult::clear_candidate() {
  if (GetArenaForAllocation() == nullptr && _impl_.candidate_ != nullptr) {
    delete _impl_.candidate_;
  }
  _impl_.candidate_ = nullptr;
}
inline const ::voting::Candidate& CandidateResult::_internal_candidate() const {
  const ::voting::Candidate* p = _impl_.candidate_;
  return p != nullptr ? *p : reinterpret_cast<const ::voting::Candidate&>(
      ::voting::_Candidate_default_instance_);
}
inline const ::voting::Candidate& CandidateResult::candidate() const {
  // @@protoc_insertion_point(field_get:voting.CandidateResult.candidate)
  return _internal_candidate();
}
inline void CandidateResult::unsafe_arena_set_allocated_candidate(
    ::voting::Candidate* candidate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.candidate_);
  }
  _impl_.candidate_ = candidate;
  if (candidate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:voting.CandidateResult.candidate)
}
inline ::voting::Candidate* CandidateResult::release_candidate() {
  
  ::voting::Candidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::voting::Candidate* CandidateResult::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_release:voting.CandidateResult.candidate)
  
  ::voting::Candidate* temp = _impl_.candidate_;
  _impl_.candidate_ = nullptr;
  return temp;
}
inline ::voting::Candidate* CandidateResult::_internal_mutable_candidate() {
  
  if (_impl_.candidate_ == nullptr) {
    auto* p = CreateMaybeMessage<::voting::Candidate>(GetArenaForAllocation());
    _impl_.candidate_ = p;
  }
  return _impl_.candidate_;
}
inline ::voting::Candidate* CandidateResult::mutable_candidate() {
  ::voting::Candidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:voting.CandidateResult.candidate)
  return _msg;
}
inline void CandidateResult::set_allocated_candidate(::voting::Candidate* candidate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.candidate_;
  }
  if (candidate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(candidate);
    if (message_arena != submessage_arena) {
      candidate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.candidate_ = candidate;
  // @@protoc_insertion_point(field_set_allocated:voting.CandidateResult.candidate)
}

// int32 votes = 2;
inline void CandidateResult::clear_votes() {
  _impl_.votes_ = 0;
}
inline int32_t CandidateResult::_internal_votes() const {
  return _impl_.votes_;
}
inline int32_t CandidateResult::votes() const {
  // @@protoc_insertion_point(field_get:voting.CandidateResult.votes)
  return _internal_votes();
}
inline void CandidateResult::_internal_set_votes(int32_t value) {
  
  _impl_.votes_ = value;
}
inline void CandidateResult::set_votes(int32_t value) {
  _internal_set_votes(value);
  // @@protoc_insertion_point(field_set:voting.CandidateResult.votes)
}

// double percent = 3;
inline void CandidateResult::clear_percent() {
  _impl_.percent_ = 0;
}
inline double CandidateResult::_internal_percent() const {
  return _impl_.percent_;
}
inline double CandidateResult::percent() const {
  // @@protoc_insertion_point(field_get:voting.CandidateResult.percent)
  return _internal_percent();
}
inline void CandidateResult::_internal_set_percent(double value) {
  
  _impl_.percent_ = value;
}
inline void CandidateResult::set_percent(double value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:voting.CandidateResult.percent)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace voting

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_voting_2eproto
